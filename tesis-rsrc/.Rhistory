if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- ddot$pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
iRB("binom", origdata, ipost(parpost, 1))
iRB("binom", origdata, ipost(parpost, 1))
iRB("betab", origdata, ipost(parpost, 1))
iRB <- function(distr, data, pars) {
# args: pars, n
n <- data$n
y <- data$y
x <- data$x
bx<- pars$bx
mu<- invlogit(x%*%bx)
if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
iRB("betab", origdata, ipost(parpost, 2))
iRB("betab", origdata, ipost(parpost, 1))
iRB("binom", origdata, ipost(parpost, 2))
iRB("binom", origdata, ipost(parpost, 1))
iRB("binom", origdata, ipost(parpost, 3))
iRB("binom", origdata, ipost(parpost, 1))
lapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i)))
lapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
unlist(a)
a
a <- unlist(a)
a
hist(a)
pchisq(a, 7)
hist(pchisq(a, 7))
range(pchisq(a, 7))
range(qchisq(a, 7))
origdata <- simu.betab.data_0.05_n1k_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_n1k_seed0
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
ipost <- function(postpar, i) {
lapply(postpar, function(x)as.matrix(x)[i, ])
}
# Func que recibe un post sample y crea los parametros necesarios segun la distribucion
iRB <- function(distr, data, pars) {
# args: pars, n
n <- data$n
y <- data$y
x <- data$x
bx<- pars$bx
mu<- invlogit(x%*%bx)
if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
lapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
quantile(pchisq(unlist(a), 7))
sapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
quantile(pchisq(a, 7))
head(a)
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
sapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
quantile(pchisq(a, 7))
loadd(simu.betab.data_0.05_n1k_seed0)
loadd(simu.binom.fit_simu.betab.data_0.05_n1k_seed0)
loadd(simu.betab.data_0.05_seed0)
loadd(simu.binom.fit_simu.betab.data_0.05_seed0)
### Inicio de "la funcion"
# Carga de los resultados previos (data + posteriores)
origdata <- simu.betab.data_0.05_n1k_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_n1k_seed0
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
# Comenzar calculo RB, un posterior sample a la vez
i <- 1 # O sea esto iria de 1:1000 (o nrow de los bx post)
n <- 7
y <- origdata$y
x <- origdata$x
bx <- parpost$bx[i,]
mu <- invlogit(x%*%bx)
# para mi caso k = y
# pk calculeshon
# ESTAZ MAL: la ubicacion de los cuantiles depende de los parametros(?)
kquants <- (0:8)*1/8
#cdf <- pbinom(y, n, mu)
# seguro que esta bien v ? piensa como afecta la observacion individual
#Pk <- c(0,cumsum(pk))
lapply(1:8, function(k) {
pk <- sum(dbinom(k-1, n, prob = mu))
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
# Calculo de R^B para una muestra de la posterior
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
quantile(rchisq(10**6, 7))
pchisq(RB, 7)
pchisq(RB, 7)
RB
a[1]
a[1]*2
library(drake)
library(tidyverse)
library(bayesplot)
library(rstan)
library(loo)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
pkgconfig::set_config("drake::strings_in_dots" = "literals")
# Inverse logistic
invlogit <- function(x)(1/(1+exp(-x)))
# Softmax
softmax <- function(x)exp(x)/sum(exp(x))
# Beta distribution mean-dispersion reparametrizer
# mu, rho -> shape1, shape2 (rbeta named parameters)
# 0 < mu < 1
# 0 < rho
repar.beta <- function(mu, rho) {
if (all(0 < mu & mu < 1 & 0 < rho)) {
list(alpha = mu / rho,
beta = (1 - mu) / rho)
} else {
stop("Parameters are out of bounds")
}
}
# Draw from reparametrized beta
rbeta.repar <- function(n, mu, rho) {
with(repar.beta(mu, rho),
rbeta(n, alpha, beta))
}
# Draw from beta-binomial (uses reparametrized beta)
rbbin <- function(n = 1000,  # samples
tries = 10,# binomial attempts
mu = 0.5, rho = 1) {
rbinom(n, tries, rbeta.repar(n, mu, rho))
}
# Label variables have a 'labels' attribute
putlabel <- function(x) {
if(is.null(attr(x, "labels"))) {
stop("No 'labels' attribute")
} else {
return(factor(x, levels = attr(x, "labels"), labels = names(attr(x, "labels"))))
}
}
# Cumulative normal-based probability vector
cumu.norm <- function(mu, s){
c(
pnorm( (0 - mu)/s ),
pnorm( (1 - mu)/s ) - pnorm( (0 - mu)/s ),
1 - pnorm( (1 - mu)/s )
) %>% matrix(ncol = 3)
}
# Simulate data for EIBB regression model estimation
eibb.sim <- function(N,      # Number of observations
n,      # Binomial size
bx = 0, bz = 0.5,    # Coefficients (beta mean, latent normal mean) - default: centered intercept
rho = 0.0001, s = 0, # Dispersion (beta, normal) - default: no beta overdispersion/endpoint inflation
sx = 0.5, sz = 0.3,  # Dispersion for covariate generation
seed = 1, # Random seed
fullinfo = FALSE) {
# Covariate generation
Kx <- length(bx)
x <- cbind(rep(1, N),
sapply(rep(N, Kx - 1), rnorm, sd = sx)) %>% unlist %>% matrix(ncol = Kx)
Kz <- length(bz)
z <- cbind(rep(1, N),
sapply(rep(N, Kz - 1), rnorm, sd = sz)) %>% unlist %>% matrix(ncol = Kz)
# Linear predictors
mu.beta <- invlogit(x %*% bx)
mu.norm <- z %*% bz
# Mixture probabilities
p <- cumu.norm(mu.norm, s)
# Latent mixture component selector
Z <- apply(p, 1, function(prob.vector) sample(1:3, size = 1, prob = prob.vector))
y <- ifelse(Z == 1, 0,
ifelse(Z == 2, rbbin(N, n, mu.beta, rho),
ifelse(Z == 3, n, NA))
)
if (fullinfo) {
list(N = N, Kx = Kx, Kz = Kz,
n = ifelse(length(n) == 1, rep(n, N), n),
y = y,
x = x, z = z,
p = p,
Z = Z,
mu.norm = mu.norm,
mu.beta = mu.beta) %>% return
} else {
list(N = N, Kx = Kx, Kz = Kz,
n = if(length(n)==1){rep(n,N)}else{n},
y = y,
x = x, z = z) %>% return
}
}
tab_looic_divergent <- function(fit){
data.frame(model = attr(fit, "model_name"),
N = attr(fit, "sim")$dims_oi$log_lik,
looic = loo(fit)$estimates[3,1],
waic = waic(extract(fit, "log_lik")$log_lik)$estimates[3,1],
divergent = get_num_divergent(fit))
}
gather_plan <- function (plan = NULL, target = "target", gather = "list") {
command <- paste(plan$target, "=", plan$command)
command <- paste(command, collapse = ", ")
command <- paste0(gather, "(", command, ")")
tibble(target = target, command = command)
}
# Endpoint-inflated binomial pmf/cdf
deibi <- function(y, mu, p1, p2, p3, n) {
if(p1+p2+p3!=1){stop("p elements must sum to 1")}
p1*ifelse(y==0, 1, 0) +
p2*dbinom(y, n, mu) +
p3*ifelse(y==n, 1, 0)
}
peibi <- function(y, mu, p1, p2, p3, n) {
pacote <- data.frame(y, mu, p1, p2, p3, n)
apply(pacote, 1,
function(x) sum(
deibi(0:x[[1]], x[[2]], x[[3]], x[[4]], x[[5]], x[[6]], x[[7]])
))
}
# Endpoint-inflated beta-binomial pmf/cdf
deibb <- function(y, mu, rho, p1, p2, p3, n) {
if(p1+p2+p3!=1){stop("p elements must sum to 1")}
p1*ifelse(y==0, 1, 0) +
p2*rmutil::dbetabinom(y, n, mu, 1/rho) +
p3*ifelse(y==n, 1, 0)
}
peibb <- function(y, mu, rho, p1, p2, p3, n) {
pacote <- data.frame(y, mu, rho, p1, p2, p3, n)
apply(pacote, 1,
function(x) sum(
deibb(0:x[[1]], x[[2]], x[[3]], x[[4]], x[[5]], x[[6]], x[[7]])
))
}
cumu.norm(1)
cumu.norm(0.5,1)
cumu.norm(0.5,0.30)
cumu.norm(0.5,0.39)
cumu.norm(0.5,0.35)
cumu.norm(0.5,0.34)
cumu.norm(0.5,0.33)
cumu.norm(0.5,0.309)
cumu.norm(0.5,0.3009)
cumu.norm(0.5,0.308)
cumu.norm(0.5,0.306)
cumu.norm(0.5,0.305)
cumu.norm(0.5,0.304)
cumu.norm(0.5,0.303)
cumu.norm(0.5,0.3039)
cumu.norm(0.5,0.304)
cumu.norm(0.5,0.309)
cumu.norm(0.5,0.304)
cumu.norm(0.5,0.303)
cumu.norm(0.5,0.3039)
cumu.norm(0.5,0.30399)
cumu.norm(0.5,0.303999)
cumu.norm(0.5,0.30399)
cumu.norm(0.5,0.30398)
cumu.norm(0.5,0.30397)
cumu.norm(0.5,0.303989)
cumu.norm(0.5,0.303985)
cumu.norm(0.5,0.303984)
cumu.norm(0.5,0.303981)
cumu.norm(0.5,0.303980)
cumu.norm(0.5,0.303975)
cumu.norm(0.5,0.303979)
cumu.norm(0.5,0.303975)
cumu.norm(0.5,0.303977)
cumu.norm(0.5,0.303978)
cumu.norm(0.5,0.303979)
cumu.norm(0.5,0.3039789)
cumu.norm(0.5,0.3039785)
cumu.norm(0.5,0.3039781)
cumu.norm(0.5,0.3039782)
cumu.norm(0.5,0.3039783)
cumu.norm(0.5,0.3039784)
cumu.norm(0.5,0.3039785)
cumu.norm(0.5,0.30397849)
cumu.norm(0.5,0.30397845)
cumu.norm(0.5,0.30397843)
cumu.norm(0.5,0.30397842)
cumu.norm(0.5,0.30397841)
cumu.norm(0.5,0.3039784)
cumu.norm(0.5,0.30397842)
cumu.norm(0.5,0.30397843)
cumu.norm(0.5,0.30397842)
cumu.norm(0.5,0.30397841)
cumu.norm(0.5,0.4
cumu.norm(0.5,0.4)
cumu.norm(0.5,0.45)
cumu.norm(0.5,0.35)
cumu.norm(0.5,0.39)
cumu.norm(0.5,0.399)
cumu.norm(0.5,0.395)
cumu.norm(0.5,0.39)
cumu.norm(0.5,0.391)
cumu.norm(0.5,0.3909)
cumu.norm(0.5,0.3905)
cumu.norm(0.5,0.3901)
cumu.norm(0.5,0.390)
cumu.norm(0.5,0.3903)
cumu.norm(0.5,0.3902)
cumu.norm(0.5,0.3901)
cumu.norm(0.5,0.39019)
cumu.norm(0.5,0.39015)
cumu.norm(0.5,0.39017)
cumu.norm(0.5,0.39016)
cumu.norm(0.5,0.39015)
cumu.norm(0.5,0.390159)
cumu.norm(0.5,0.390157)
cumu.norm(0.5,0.390155)
cumu.norm(0.5,0.390153)
cumu.norm(0.5,0.390151)
cumu.norm(0.5,0.390152)
cumu.norm(0.5,0.390153)
cumu.norm(0.5,0.390152)
cumu.norm(0.5,0.3901529)
cumu.norm(0.5,0.3901526)
cumu.norm(0.5,0.3901524)
cumu.norm(0.5,0.3901523)
cumu.norm(0.5,0.3901522)
cumu.norm(0.5,0.3901521)
cumu.norm(0.5,0.4)
cumu.norm(0.5,0.5)
cumu.norm(0.5,0.49)
cumu.norm(0.5,0.46)
cumu.norm(0.5,0.47)
cumu.norm(0.5,0.48)
cumu.norm(0.5,0.49)
cumu.norm(0.5,0.484)
cumu.norm(0.5,0.482)
cumu.norm(0.5,0.4829)
cumu.norm(0.5,0.4825)
cumu.norm(0.5,0.4824)
cumu.norm(0.5,0.4824)
cumu.norm(0.5,0.48245)
cumu.norm(0.5,0.48242)
cumu.norm(0.5,0.48243)
cumu.norm(0.5,0.482425)
cumu.norm(0.5,0.482421)
cumu.norm(0.5,0.482422)
cumu.norm(0.5,0.482423)
cumu.norm(0.5,0.482424)
cumu.norm(0.5,0.4824236)
cumu.norm(0.5,0.4824235)
cumu.norm(0.5,0.4824236)
cumu.norm(0.5,0.4824237)
cumu.norm(0.5,0.5)
cumu.norm(0.5,0.6)
cumu.norm(0.5,0.58)
cumu.norm(0.5,0.59)
cumu.norm(0.5,0.599)
cumu.norm(0.5,0.595)
cumu.norm(0.5,0.593)
cumu.norm(0.5,0.5939)
cumu.norm(0.5,0.59399)
cumu.norm(0.5,0.594)
cumu.norm(0.5,0.5949)
cumu.norm(0.5,0.5945)
cumu.norm(0.5,0.5941)
cumu.norm(0.5,0.59409)
cumu.norm(0.5,0.5941)
cumu.norm(0.5,0.59409)
cumu.norm(0.5,0.594099)
cumu.norm(0.5,0.594095)
cumu.norm(0.5,0.59409)
cumu.norm(0.5,0.594093)
cumu.norm(0.5,0.594092)
cumu.norm(0.5,0.594091)
cumu.norm(0.5,0.5940919)
cumu.norm(0.5,0.5940915)
cumu.norm(0.5,0.7)
cumu.norm(0.5,0.8)
cumu.norm(0.5,0.7)
cumu.norm(0.5,0.75)
cumu.norm(0.5,0.74)
cumu.norm(0.5,0.749)
cumu.norm(0.5,0.747)
cumu.norm(0.5,0.744)
cumu.norm(0.5,0.743)
cumu.norm(0.5,0.742)
cumu.norm(0.5,0.741)
cumu.norm(0.5,0.7419)
cumu.norm(0.5,0.7415)
cumu.norm(0.5,0.7412)
cumu.norm(0.5,0.7413)
cumu.norm(0.5,0.74139)
cumu.norm(0.5,0.74135)
cumu.norm(0.5,0.74132)
cumu.norm(0.5,0.74131)
cumu.norm(0.5,0.741309)
cumu.norm(0.5,0.741305)
cumu.norm(0.5,0.741303)
cumu.norm(0.5,0.741301)
cumu.norm(0.5,0.7413009)
cumu.norm(0.5,0.741309)
cumu.norm(0.5,0.741301)
cumu.norm(0.5,0.7413011)
cumu.norm(0.5,0.9)
cumu.norm(0.5,0.1)
cumu.norm(0.5,1)
cumu.norm(0.5,0.99)
cumu.norm(0.5,0.95)
cumu.norm(0.5,0.959)
cumu.norm(0.5,0.955)
cumu.norm(0.5,0.951)
cumu.norm(0.5,0.952)
cumu.norm(0.5,0.953)
cumu.norm(0.5,0.9539)
cumu.norm(0.5,0.9535)
cumu.norm(0.5,0.9531)
cumu.norm(0.5,0.9532)
cumu.norm(0.5,0.9533)
cumu.norm(0.5,0.9534)
cumu.norm(0.5,0.9535)
cumu.norm(0.5,0.95349)
cumu.norm(0.5,0.95345)
cumu.norm(0.5,0.95347)
cumu.norm(0.5,0.95346)
cumu.norm(0.5,0.953469)
cumu.norm(0.5,0.9534699)
cumu.norm(0.5,0.95346999)
cumu.norm(0.5,0.953469)
cumu.norm(0.5,0.9534695)
cumu.norm(0.5,0.95346955)
cumu.norm(0.5,0.95346956)
cumu.norm(0.5,0.95346957)
cumu.norm(0.5,0.95346959)
cumu.norm(0.5,0.7413011)
cumu.norm(0.5,0.30397842)
