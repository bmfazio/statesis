# Carga de los resultados previos (data + posteriores)
origdata <- simu.betab.data_0.05_n1k_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_n1k_seed0
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
# Comenzar calculo RB, un posterior sample a la vez
i <- 1 # O sea esto iria de 1:1000 (o nrow de los bx post)
n <- 7
y <- origdata$y
x <- origdata$x
bx <- parpost$bx[i,]
mu <- invlogit(x%*%bx)
# para mi caso k = y
# pk calculeshon
# ESTAZ MAL: la ubicacion de los cuantiles depende de los parametros(?)
kquants <- (0:8)*1/8
#cdf <- pbinom(y, n, mu)
# seguro que esta bien v ? piensa como afecta la observacion individual
#Pk <- c(0,cumsum(pk))
lapply(1:8, function(k) {
k <- 1
pk <- dbinom(k-1, n, prob = mu)
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
head(rbk)
rbk
rbk$mk
rbk$mk %>% table
head(rbk)
RB <- with(rbk, sum(((mk - N*pk)/sqrt(N*pk))**2))
lapply(1:8, function(k) {
k <- 1
pk <- 1000*dbinom(k-1, n, prob = mu)
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
# Calculo de R^B para una muestra de la posterior
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
RB
head(rbk)
lapply(1:8, function(k) {
pk <- 1000*dbinom(k-1, n, prob = mu)
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
head(rbk)
lapply(1:8, function(k) {
pk <- 1000*dbinom(k-1, n, prob = mu)
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) -> rbk
head(rbk)
rbk[[1]]
rbk[[2]]
rbk[[3]]
rbk[[4]]
lapply(1:8, function(k) {
pk <- 1000*dbinom(k-1, n, prob = mu)
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
rbk$mk %>% table
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
RB
head(rbk)
lapply(1:8, function(k) {
pk <- sum(dbinom(k-1, n, prob = mu))
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
rbk
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
RB
pchisq(8)
pchisq(8, 1)
pchisq(10, 7)
pchisq(42.87, 7)
rbk$pk %>% sum
rbk$mk %>% sum
quantile(rchisq(10**6, 7))
pchisq(RB, 7)
loadd(simu.betab.data_0.05_seed0)
loadd(simu.binom.fit_simu.betab.data_n1k_seed0)
### Inicio de "la funcion"
# Carga de los resultados previos (data + posteriores)
origdata <- simu.betab.data_0.05_n1k_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_n1k_seed0
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
loadd(simu.binom.fit_simu.betab.data_0.05_seed0)
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
# Comenzar calculo RB, un posterior sample a la vez
i <- 1 # O sea esto iria de 1:1000 (o nrow de los bx post)
n <- 7
y <- origdata$y
x <- origdata$x
bx <- parpost$bx[i,]
mu <- invlogit(x%*%bx)
# para mi caso k = y
# pk calculeshon
# ESTAZ MAL: la ubicacion de los cuantiles depende de los parametros(?)
kquants <- (0:8)*1/8
#cdf <- pbinom(y, n, mu)
# seguro que esta bien v ? piensa como afecta la observacion individual
#Pk <- c(0,cumsum(pk))
lapply(1:8, function(k) {
pk <- sum(dbinom(k-1, n, prob = mu))
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
# Calculo de R^B para una muestra de la posterior
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
quantile(rchisq(10**6, 7))
pchisq(RB, 7)
curve(pnorm(x),-1,1)
curve(pnorm(x),-5,5)
curve(pnorm(x),-1,1)
curve(pnorm(x),-5,5)
parpost
parpost %>% str
nrow(parpost$bx)
posteriorN <- nrow(parpost$bx)
posteriorN
ipost <- function(postpar, i) {
lapply(postpar, function(x)x[i, ])
}
parpost
ipost(parpost, 1)
ipost(parpost, 2)
dis
dist
dist(0:1)
dist(0:5)
dist(1:5,8:12)
dist(1:5,8:13)
?dist
ddist
pdist
dist
distr
...
...elt()
fdsu
`1`
`...`
?`...`
??`...`
?`...`
a <- function(...){print(...)}
a(1)
a(1,2)
a(1,2,3)
a <- function(...){print(list(...))}
a(1,2,3)
a(list(a=1,b=2),1)
a(list(a=1,b=2))
a(b=list(a=1,b=2))
a(b=list(a=1,b=2)) -> b
b
b$b
b$b$a
?dbinom
my_ellipsis_function <- function(...) {
input_list <- as.list(substitute(list(...)))
}
print(my_ellipsis_function(a=1:10, b=2:20))
(my_ellipsis_function(a=1:10, b=2:20))
(my_ellipsis_function(a=1:10, b=2:20)) -> a
str(a)
a[[1]]
a[[2]]
a[[3]]
a[[1]]
str(a[[1]])
typeof(a[[1]])
list(a)
list(a)[[1]]
library(rmutil)
?rmutil
?rmutil::dbetabinom
rmutil::dbetabinom(y, n, mu, 1/rho)
rmutil::dbetabinom(1, 2, 0.5, 1)
rmutil::dbetabinom(1, 2, 0.5, 0)
rmutil::dbetabinom(1, 2, 0.5, 0.0000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.00000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.00000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
rmutil::dbetabinom(1, 2, 0.5, 11)
rmutil::dbetabinom(1, 2, 0.5, 1000000000000000000000000000000000000000000000)
rmutil::dbetabinom(1, 2, 0.5, 10)
rmutil::dbetabinom(1, 2, 0.5, 10000000000000000000000)
rmutil::dbetabinom(1, 2, 0.5, 1000000000000)
rmutil::dbetabinom(0, 2, 0.5, 1000000000000)
rmutil::dbetabinom(1, 2, 0.5, 1000000000000)
rmutil::dbetabinom(3, 2, 0.5, 1000000000000)
rmutil::dbetabinom(0, 2, 0.5, 1000000000000)
rmutil::dbetabinom(0, 2, 0.5, 1000000000000)+rmutil::dbetabinom(1, 2, 0.5, 1000000000000)+rmutil::dbetabinom(2, 2, 0.5, 1000000000000)
rmutil::dbetabinom
deibi <- function(y, mu, p1, p2, p3, n) {
if(p1+p2+p3!=1){stop("p elements must sum to 1")}
p1*ifelse(y==0, 1, 0) +
p2*dbinom(y, n, mu) +
p3*ifelse(y==n, 1, 0)
}
peibi <- function(y, mu, p1, p2, p3, n) {
pacote <- data.frame(y, mu, p1, p2, p3, n)
apply(pacote, 1,
function(x) sum(
deibi(0:x[[1]], x[[2]], x[[3]], x[[4]], x[[5]], x[[6]], x[[7]])
))
}
1:3%*%5:7
deibi
1:3%*%2
2%*%1:3
2%*%t(1:3)
mun
cumu.norm
iRB <- function(distr, data, pars) {
# args: pars, n
dddot <- list(...)
n <- dddot$data$n
y <- dddot$data$y
x <- dddot$data$x
bx<- dddot$pars$bx
mu<- invlogit(x%*%bx)
if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- ddot$pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(dddot$data$z%*%dddot$data$bz, dddot$data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(dddot$data$z%*%dddot$data$bz, dddot$data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
ipost
ipost(modelfit, 1)
modelfit
ipost(extract(modelfit), 1)
extract(modelfit)
extract(modelfit) -> a
extract(modelfit) -> a
ipost(extract(modelfit), 1)
a$mu_beta
a$mu_beta[1,]
as.matrix(a$mu_beta)[1,]
as.matrix(a$bx)[1,]
identical(as.matrix(a$bx),a$bx)
identical(as.matrix(a$mu_beta),a$mu_beta)
ipost <- function(postpar, i) {
lapply(postpar, function(x)as.matrix(x)[i, ])
}
ipost(extract(modelfit), 1)
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
parpost
ipost(parpost, 1)
iRB("binom", origdata, ipost(parpost,1))
iRB <- function(distr, data, pars) {
# args: pars, n
n <- data$n
y <- data$y
x <- data$x
bx<- pars$bx
mu<- invlogit(x%*%bx)
if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- ddot$pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
iRB("binom", origdata, ipost(parpost, 1))
iRB("binom", origdata, ipost(parpost, 1))
iRB("betab", origdata, ipost(parpost, 1))
iRB <- function(distr, data, pars) {
# args: pars, n
n <- data$n
y <- data$y
x <- data$x
bx<- pars$bx
mu<- invlogit(x%*%bx)
if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
iRB("betab", origdata, ipost(parpost, 2))
iRB("betab", origdata, ipost(parpost, 1))
iRB("binom", origdata, ipost(parpost, 2))
iRB("binom", origdata, ipost(parpost, 1))
iRB("binom", origdata, ipost(parpost, 3))
iRB("binom", origdata, ipost(parpost, 1))
lapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i)))
lapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
unlist(a)
a
a <- unlist(a)
a
hist(a)
pchisq(a, 7)
hist(pchisq(a, 7))
range(pchisq(a, 7))
range(qchisq(a, 7))
origdata <- simu.betab.data_0.05_n1k_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_n1k_seed0
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
ipost <- function(postpar, i) {
lapply(postpar, function(x)as.matrix(x)[i, ])
}
# Func que recibe un post sample y crea los parametros necesarios segun la distribucion
iRB <- function(distr, data, pars) {
# args: pars, n
n <- data$n
y <- data$y
x <- data$x
bx<- pars$bx
mu<- invlogit(x%*%bx)
if(distr == "binom") {
ddist <- function(y) dbinom(y, n, mu)
pdist <- function(y) pbinom(y, n, mu)
} else if(distr == "betab") {
rho <- pars$rho
ddist <- function(y) rmutil::dbetabinom(y, n, mu, 1/rho)
pdist <- function(y) rmutil::pbetabinom(y, n, mu, 1/rho)
} else if(distr == "eibin") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibi(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibi(y, mu, p[1], p[2], p[3], n)
} else if(distr == "eibeb") {
p <- cumu.norm(data$z%*%data$bz, data$sigma)
ddist <- function(y) deibb(y, mu, p[1], p[2], p[3], n)
pdist <- function(y) peibb(y, mu, p[1], p[2], p[3], n)
} else {
stop("Undefined distribution")
}
# Llamar a RB con ddist y pdist
rbk <- lapply(1:8, function(k) {
pk <- sum(ddist(k-1))
ak <- pdist(k-1.1)
Fy <- pdist(y)
aK <- pdist(k-1)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .)
with(rbk, sum(((mk - pk)/sqrt(pk))**2))
}
lapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
quantile(pchisq(unlist(a), 7))
sapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
quantile(pchisq(a, 7))
head(a)
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
sapply(1:1000,function(i)iRB("binom", origdata, ipost(parpost, i))) -> a
quantile(pchisq(a, 7))
loadd(simu.betab.data_0.05_n1k_seed0)
loadd(simu.binom.fit_simu.betab.data_0.05_n1k_seed0)
loadd(simu.betab.data_0.05_seed0)
loadd(simu.binom.fit_simu.betab.data_0.05_seed0)
### Inicio de "la funcion"
# Carga de los resultados previos (data + posteriores)
origdata <- simu.betab.data_0.05_n1k_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_n1k_seed0
origdata <- simu.betab.data_0.05_seed0
modelfit <- simu.binom.fit_simu.betab.data_0.05_seed0
allPars <- c("bx", "bz", "rho", "sigma")
fitPars <- attributes(modelfit)$model_pars
parpost <- extract(modelfit, intersect(allPars, fitPars))
# Comenzar calculo RB, un posterior sample a la vez
i <- 1 # O sea esto iria de 1:1000 (o nrow de los bx post)
n <- 7
y <- origdata$y
x <- origdata$x
bx <- parpost$bx[i,]
mu <- invlogit(x%*%bx)
# para mi caso k = y
# pk calculeshon
# ESTAZ MAL: la ubicacion de los cuantiles depende de los parametros(?)
kquants <- (0:8)*1/8
#cdf <- pbinom(y, n, mu)
# seguro que esta bien v ? piensa como afecta la observacion individual
#Pk <- c(0,cumsum(pk))
lapply(1:8, function(k) {
pk <- sum(dbinom(k-1, n, prob = mu))
ak <- pbinom(k-1.1, n, prob = mu)
Fy <- pbinom(y, n, prob = mu)
aK <- pbinom(k-1, n, prob = mu)
mk <- sum(ifelse(ak <Fy&Fy<= aK, 1, 0))
data.frame(pk = pk, mk = mk)
}) %>% do.call(rbind, .) -> rbk
# Calculo de R^B para una muestra de la posterior
RB <- with(rbk, sum(((mk - pk)/sqrt(pk))**2))
quantile(rchisq(10**6, 7))
pchisq(RB, 7)
pchisq(RB, 7)
RB
a[1]
a[1]*2
